Главная особенность кода - изменяемость. 
Со временем меняются люди, цели, задачи, обстоятельства.
Соответсвенно необходимо будет менять и написанный код. 
Время и усилия людей, затраченные на адаптацию кода к изменившимся условиям называют поддержкой. 
Написанному коду всегда нужна поддержка. 
Сколько времени и сил уйдет на поддержку зависит от архитектуры.
У архитектуры кода, есть общие принципы её построения. Они базируются на принципах ООП, расширяют и дополняют их.
- АБСТРАКЦИЯ
- ИНКАПСУЛЯЦИЯ
- ПОЛИМОРФИЗМ  
- НАСЛЕДОВАНИЕ 


Принципы Архитектуры ПО

1. "Инкапсулировать изменяемое". 
Выделить изменяемые аспекты поведения и инкапсулировать их.
	
	class A{
		void doSmth(){
			//do it like A does;
		}
	}
	
	class B extends A {
		//you do it like A or override;
	}
	
	interface DoSmth{
		void doSmth();
	}
	
	class A,B,C... implements DoSmth{
		//everybody do smth;
	}
	
2. "Программировать на уровне интерфейсов".

	уровень реализации
	
	class Dog{
		void bark(){
			//bark somehow;
		}
	}	
	Dog dog = new Dog();
	dog.bark();

	уровень интерфейса
	
	interface SoundPerformer{
		void performSound();
	}	
	
	class Dog implement SoundPerformer{
		void performSound(){
			//bark like a dog;
		}
	}
	
	Dog dog = new Dog();
	dog.performSound();
	
3. "Композиция вместо наследования".
Впоследствии можно делегировать исполнение этого алгоритма вообще кому угодно. 
	
	interface SoundPerformer{
		void performSound();
	}
	
	class SoundPerformerImpl implements SoundPerformer{
		void performSound(){
			//bark like dog;
		}
	}
	
	class Dog{
		SoundPerformer performer;
		
		public Dog(SoundPerformer sp){
			performer = sp;
		}
		
		void bark(){
			performer.perfomSound();
		}
	}

4. "Слабая связь взаимодействующих объектов". 
Реализации должны "знать друг о друге" как можно меньше. 

	interface SoundPerformer{
		void performSound();
	}
	abstract class Animal{
		SoundPerformer performer;

		void makeSound(){
			performer.performSound();
		}
	}
		
	Animal animal = getAnimal();
	animal.makeSound();

5. Открытость компонентов к расширению при закрытости к изменениям.
Нужно предусматривать возможность для легкого расширения кода. Это минимизирует необходимость изменений. 

6. "Код должен зависеть от абстракций, а не от реализаций". Принцип инверсии зависимостей. 
Высокоуровневые компоненты не должны зависеть от низкоуровневых компонентов. И те, и другие должны зависеть от абстракций. Инверсия зависимостей - это путь программировать на уровне интерфейсов, а не реализаций.

7. "Общайся только с близкими друзьями". Принцип минимальной информированности. 
Создавать архитектуру, в которой класс имеет минимальное количество связей с другими классами.
Для этого рекомендуется запускать методы
- самого класса
- его компонетов (ссылки на другие классы)
- объектов, которые передали параметрами в методы класса
- объектов, которые созданы внутри методов класса
  	
8. "Не надо нам звонить, мы сами вам позвоним" 
Голливудский принцип. Высокоуровневые компоненты сами принимают решение когда и как вызывать низкоуровневые компоненты.

