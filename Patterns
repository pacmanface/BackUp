1."Стратегия" - выделяет семейство алгоритмов и инкапсулирует их. Что позволяет расширять алгоритм, 
безопасно менять его реализации и динамически исполнять их за счет делегирования поведения другому объекту.
Реализуется принцип выделения переменных аспектов поведения и их инкапсуляции.

2. "Наблюдатель" - демонстрирует тип отношений ОДИН КО МНОГИМ. Измененения в состоянии наблюдаемого объекта активируют поведение наблюдателей. Наблюдаемый ничего не знает о наблюдателях, а они о нем.
Реализует принцип слабой связи взаимодействующих объектов.

3. "Декоратор" - динамически расширяет(дополняет, декорирует) поведение объекта за счет субклассирования. Код декорируемых объектов не меняется. Декоратор имеет один тип с компонентом, чтобы иметь возможность субклассирования.
Реализует принцип открытости к расширению/закрытости к изменениям.

4. "Фабричный метод" - инкапсулирует создание объектов в отдельном абстрактном методе, реализация которого делегируется субклассам.
4.1 "Абстрактная фабрика" - фабричный метод выносится из абстрактного класса в интерфейс. Конкретные реализации интерфеса внедряются в объект с помощью композиции. 
4.2 "Простая фабрика" - идиома. Создание экземпляров класса выносится в статический метод отдельного класса. 
Фабричные паттерны реализуют принцип инверсии зависимостей - код должен зависеть от абстракций, а не от конкретных реализаций.

5. "Одиночка" - паттерн, гарантирующий существование только одного экземпляра класса и обеспечивающий глобальный доступ к последнему. но это не точно))
Два загрузчика классов могут загрузить 2 синглтона.

class MySingle{
	private MySingle(){}
	private static MySingle single;
	
	public static MySingle getInstance(){
		if(single==null) single = new MySingle();
		return single;
	}
}
Несинхронизированный одиночка не гарантирует существование только 1 экземпляра класса.

class MySingle{
	private MySingle(){}
	private static MySingle single;
	
	public static synchronized MySingle getInstance(){
		if(single==null) single = new MySingle();
		return single;
	}
}
Синхронизация будет проходить каждый раз (хотя уникальный объект надежно создастся при первом вызове метода) 
и сожрет больше ресурсов, чем сохранит их "ленивое" создание экземпляра.

class MySingle{
	private MySingle(){}
	private volatile static MySingle single;
	
	public static MySingle getInstance(){
		if(single==null){
			synchronized(MySingle.class){
				if(single==null) single = new MySingle();
			}
		}
		return single;
	}
}
Создание уникального объекта произойдет при первом обращении к методу. Дальше просто раздача синглтона.
Хотя синхронизацию пройдет столько раз, сколькопотоков успеет вы полнить if(single == null)

class MySingle{
	private MySingle(){}
	private static MySingle single = new MySingle();
	
	public static MySingle getInstance(){
		return single;
	}
}

Потокобезопасно. Создание уникального экземпляра на этапе загрузки класса. Нелениво.

class MySingle{
	private MySingle(){}
	public final static MySingle SINGLE = new MySingle();	
}

???
enum MySingle{
	 new MySingle();
}














